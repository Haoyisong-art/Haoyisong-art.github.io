<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Spiritual Space</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            overflow: hidden;
            background: #000;
            color: white;
        }

        /* Cosmos canvas backdrop */
        #cosmosCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Particle canvas overlay */
        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        /* Top-left badge */
        .animism-badge {
            position: fixed;
            top: 2rem;
            left: 2rem;
            z-index: 10;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 0.9rem;
            color: white;
            letter-spacing: 0.5px;
        }

        /* Prayer overlay - center content */
        .prayer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4;
            padding: 2rem;
            pointer-events: none;
        }

        .prayer-overlay > * {
            pointer-events: auto;
        }

        .prayer-text {
            max-width: 700px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        .prayer-text.visible {
            opacity: 1;
        }

        .prayer-text p {
            color: #ffffff;
            line-height: 2;
            font-size: 1.3rem;
            font-style: italic;
            text-shadow: 0 3px 8px rgba(0,0,0,0.9);
        }

        /* Additional input */
        .additional-input {
            margin-top: 1rem;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .additional-input.visible {
            opacity: 1;
        }

        .additional-input input {
            padding: 0.6rem 1.2rem;
            width: 300px;
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
            color: white;
            backdrop-filter: blur(10px);
            font-size: 0.9rem;
            text-align: center;
        }

        .additional-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        /* Bottom prayer bar */
        .prayer-bar {
            position: fixed;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 0.8rem;
            transition: opacity 0.3s ease;
        }

        .prayer-bar.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .prayer-button {
            background: transparent;
            color: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 400;
            font-family: 'Georgia', serif;
            letter-spacing: 0.3px;
        }

        .prayer-button:hover {
            color: #ffffff;
            transform: scale(1.05);
        }

        /* Element selector - below input */
        .element-selector {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 0.6rem;
            margin-top: 1rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .element-selector.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .element-selector-title {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            margin-right: 0.5rem;
            text-align: center;
            line-height: 1.3;
        }

        .element-emoji {
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.2rem;
            opacity: 0.8;
        }

        .element-emoji:hover {
            transform: scale(1.2);
            opacity: 1;
        }

        /* Collaboration credit */
        .collaboration-credit {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            line-height: 1.4;
        }

        /* Pray again button */
        .pray-again-button {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 10;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 0.6rem 1.2rem;
            font-size: 0.85rem;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
        }

        .pray-again-button.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .pray-again-button:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .prayer-bar {
                bottom: 2rem;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.6rem;
            }

            .prayer-button {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }

            .element-selector {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .element-emoji {
                font-size: 1.2rem;
            }

            .element-selector-title {
                font-size: 0.65rem;
            }

            .prayer-text p {
                font-size: 1.1rem;
            }

            .animism-badge {
                top: 1rem;
                left: 1rem;
                font-size: 0.8rem;
                padding: 0.5rem 1rem;
            }

            .collaboration-credit {
                font-size: 0.65rem;
            }
        }
    </style>
</head>
<body>
    <!-- Animism badge -->
    <div class="animism-badge">Animism ¬∑ ‰∏áÁâ©ÁÅµ</div>

    <!-- Cosmos canvas -->
    <canvas id="cosmosCanvas"></canvas>

    <!-- Particle canvas -->
    <canvas id="particleCanvas"></canvas>

    <!-- Prayer overlay -->
    <div class="prayer-overlay">
        <div class="prayer-text" id="prayerText">
            <p></p>
        </div>
        <div class="additional-input" id="additionalInput">
            <input type="text" id="additionalPrayer" placeholder="Add your own words...">
        </div>

        <!-- Element selector - below input -->
        <div class="element-selector" id="elementSelector">
            <div class="element-selector-title">Send with ¬∑ ‰º†ÈÄÅ</div>
            <div class="element-emoji" data-element="metal" title="Metal ¬∑ Èáë">üí∞</div>
            <div class="element-emoji" data-element="wood" title="Wood ¬∑ Êú®">üå≥</div>
            <div class="element-emoji" data-element="water" title="Water ¬∑ Ê∞¥">üíß</div>
            <div class="element-emoji" data-element="fire" title="Fire ¬∑ ÁÅ´">üî•</div>
            <div class="element-emoji" data-element="earth" title="Earth ¬∑ Âúü">‚õ∞Ô∏è</div>
        </div>
    </div>

    <!-- Bottom prayer bar -->
    <div class="prayer-bar" id="prayerBar">
        <button class="prayer-button" onclick="generatePrayer('en', 'pray')">Pray</button>
        <button class="prayer-button" onclick="generatePrayer('zh', 'pray')">Á•àÁ•∑</button>
        <button class="prayer-button" onclick="generatePrayer('en', 'relief')">Relief</button>
        <button class="prayer-button" onclick="generatePrayer('zh', 'relief')">Ê∂àÁÅæ</button>
    </div>

    <!-- Pray again button -->
    <button class="pray-again-button" id="prayAgainButton" onclick="restartPrayer()">Pray Again</button>

    <!-- Collaboration credit -->
    <div class="collaboration-credit">
        Tech support by Dr. Yilan Liu<br>
        Co-created with Claude ¬∑ ‰∏éClaudeÂÖ±ÂêåÂàõ‰Ωú
    </div>

    <!-- Background audio -->
    <audio id="backgroundAudio" loop>
        <source src="audio/relaxing-birds-and-piano-music-137153.mp3" type="audio/mpeg">
    </audio>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============================================
        // THREE.JS COSMOS SETUP
        // ============================================
        let scene, camera, renderer, stars, comet;
        let cometActive = false;

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            const canvas = document.getElementById('cosmosCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // High DPI

            // Starfield
            createStarfield();

            // Animation loop
            animateCosmos();

            // Resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 3000;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;     // x
                positions[i + 1] = (Math.random() - 0.5) * 100; // y
                positions[i + 2] = (Math.random() - 0.5) * 100; // z
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });

            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function launchComet() {
            if (cometActive) return;

            // Remove old comet if exists
            if (comet) {
                scene.remove(comet);
            }

            // Create star shape for comet head (4 times smaller)
            const starShape = new THREE.Shape();
            const outerRadius = 0.0375;  // 0.15 / 4
            const innerRadius = 0.015;   // 0.06 / 4
            const points = 5;

            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i / (points * 2)) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) {
                    starShape.moveTo(x, y);
                } else {
                    starShape.lineTo(x, y);
                }
            }
            starShape.closePath();

            const headGeometry = new THREE.ShapeGeometry(starShape);
            const headMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);

            // Add subtle glow around star (4 times smaller)
            const glowGeometry = new THREE.SphereGeometry(0.05, 16, 16);  // 0.2 / 4
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.25
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            head.add(glow);

            // Create line trail with gradient fade
            const trailPoints = [];
            const trailLength = 50;
            for (let i = 0; i < trailLength; i++) {
                trailPoints.push(new THREE.Vector3(0, 0, 0));
            }

            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            const trailMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);

            // Starting position (from left-bottom)
            const startX = -12;
            const startY = -8;
            head.position.set(startX, startY, 2);

            // Store comet data
            comet = {
                head: head,
                trail: trail,
                trailPoints: trailPoints,
                time: 0,
                startX: startX,
                startY: startY,
                positions: []
            };

            scene.add(head);
            scene.add(trail);
            cometActive = true;

            // Animate comet
            animateComet();
        }

        function animateComet() {
            if (!comet || !cometActive) return;

            // Increment time for curved path
            comet.time += 0.025;
            const t = comet.time;

            // Curved trajectory using parametric equations
            const speed = 0.25;
            const newX = comet.startX + t * speed * 8;
            const newY = comet.startY + t * speed * 6 + Math.sin(t * 0.8) * 1.5;
            const newZ = 2 + Math.cos(t * 0.5) * 0.5;

            // Update head position
            comet.head.position.set(newX, newY, newZ);

            // Store position history
            comet.positions.unshift(new THREE.Vector3(newX, newY, newZ));
            if (comet.positions.length > 50) {
                comet.positions.pop();
            }

            // Update trail positions with fading effect
            const trailPositions = comet.trail.geometry.attributes.position;
            for (let i = 0; i < comet.positions.length; i++) {
                if (comet.positions[i]) {
                    trailPositions.setXYZ(
                        i,
                        comet.positions[i].x,
                        comet.positions[i].y,
                        comet.positions[i].z
                    );
                }
            }
            trailPositions.needsUpdate = true;

            // Fade trail opacity based on position in trail
            const colors = new Float32Array(50 * 3);
            for (let i = 0; i < 50; i++) {
                const fade = 1 - (i / 50);
                colors[i * 3] = fade;     // r
                colors[i * 3 + 1] = fade; // g
                colors[i * 3 + 2] = fade; // b
            }
            comet.trail.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            comet.trail.material.vertexColors = true;

            // Fade out as it moves far
            if (newX > 12) {
                comet.head.material.opacity -= 0.015;
                comet.trail.material.opacity -= 0.015;

                if (comet.head.material.opacity <= 0) {
                    scene.remove(comet.head);
                    scene.remove(comet.trail);
                    cometActive = false;
                    return;
                }
            }

            requestAnimationFrame(animateComet);
        }

        function animateCosmos() {
            requestAnimationFrame(animateCosmos);

            // Slowly rotate starfield
            if (stars) {
                stars.rotation.y += 0.0002;
                stars.rotation.x += 0.0001;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Also resize particle canvas
            const particleCanvas = document.getElementById('particleCanvas');
            particleCanvas.width = window.innerWidth * window.devicePixelRatio;
            particleCanvas.height = window.innerHeight * window.devicePixelRatio;
            particleCanvas.style.width = window.innerWidth + 'px';
            particleCanvas.style.height = window.innerHeight + 'px';
            particleCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        let particleCanvas, particleCtx, particles = [];
        let currentPrayerMode = 'pray';

        function initParticleCanvas() {
            particleCanvas = document.getElementById('particleCanvas');
            particleCtx = particleCanvas.getContext('2d');

            // High DPI canvas
            particleCanvas.width = window.innerWidth * window.devicePixelRatio;
            particleCanvas.height = window.innerHeight * window.devicePixelRatio;
            particleCanvas.style.width = window.innerWidth + 'px';
            particleCanvas.style.height = window.innerHeight + 'px';
            particleCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        class Particle {
            constructor(char, x, y, type) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = Math.random() * 3 + 2;
                this.opacity = 1;
                this.life = 1;
                this.trail = [];
                this.birthDelay = Math.random() * 120; // 0-2 seconds
                this.showChar = char !== '';
                this.charToParticleProgress = char === '' ? 1 : 0;
                this.age = 0;

                // Initialize movement based on type
                this.initMovement(type);
            }

            initMovement(type) {
                if (type === 'metal') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.spiralRadius = Math.random() * 20;
                    this.spiralSpeed = (Math.random() - 0.5) * 0.1;
                    this.upwardSpeed = Math.random() * 2 + 1;
                    this.shimmer = Math.random() * Math.PI * 2;
                    this.shimmerSpeed = Math.random() * 0.2 + 0.1;
                    this.metalColor = Math.random() > 0.5 ? 'silver' : 'gold';
                } else if (type === 'wood') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = -Math.random() * 2.5 - 1.5;
                    this.swirl = Math.random() * Math.PI * 2;
                    this.swirlSpeed = Math.random() * 0.15 + 0.1;
                } else if (type === 'water') {
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = Math.random() * 0.5 - 2;
                    this.wave = Math.random() * Math.PI * 2;
                    this.waveSpeed = Math.random() * 0.15 + 0.1;
                } else if (type === 'fire') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = -Math.random() * 4 - 2;
                    this.flicker = Math.random() * Math.PI;
                    this.flickerSpeed = Math.random() * 0.3 + 0.2;
                } else if (type === 'earth') {
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = -Math.random() * 2 - 1;
                    this.float = Math.random() * Math.PI * 2;
                    this.floatSpeed = Math.random() * 0.08 + 0.05;
                } else if (type === 'shatter') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.gravity = 0.3;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotSpeed = (Math.random() - 0.5) * 0.3;
                } else if (type === 'wood-break') {
                    this.vx = (Math.random() - 0.5) * 1.5;
                    this.vy = Math.random() * 0.5;
                    this.gravity = 0.08;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotSpeed = (Math.random() - 0.5) * 0.08;
                } else if (type === 'flood') {
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = Math.random() * 0.6 + 0.3;
                    this.wave = Math.random() * Math.PI * 2;
                    this.waveSpeed = Math.random() * 0.08 + 0.05;
                } else if (type === 'burn') {
                    this.vx = (Math.random() - 0.5) * 0.8;
                    this.vy = 0;
                    this.burnStage = 0;
                    this.flicker = Math.random() * Math.PI;
                    this.flickerSpeed = Math.random() * 0.25 + 0.15;
                } else if (type === 'earth-crack') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.speed = Math.random() * 0.8 + 0.3;
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.gravity = 0.05;
                }
            }

            update() {
                // Handle birth delay
                if (this.birthDelay > 0) {
                    this.birthDelay--;
                    return;
                }

                this.age++;

                // Gradual character transformation
                if (this.showChar && this.charToParticleProgress < 1) {
                    this.charToParticleProgress += 0.011;
                }

                // Update position based on type
                this.updatePosition();

                // Slower fade - 5+ seconds minimum
                this.life -= 0.0012; // ~833 frames = ~13.9 seconds at 60fps
                this.opacity = Math.max(0, this.life);
            }

            updatePosition() {
                if (this.type === 'metal') {
                    this.angle += this.spiralSpeed;
                    this.y -= this.upwardSpeed;
                    this.x += Math.cos(this.angle) * this.spiralRadius;
                    this.spiralRadius += 0.3;
                    this.shimmer += this.shimmerSpeed;
                } else if (this.type === 'wood') {
                    this.swirl += this.swirlSpeed;
                    this.x += this.vx + Math.cos(this.swirl) * 3;
                    this.y += this.vy;
                    this.vy -= 0.03;
                } else if (this.type === 'water') {
                    this.wave += this.waveSpeed;
                    this.x += this.vx + Math.sin(this.wave) * 4;
                    this.y += this.vy;
                } else if (this.type === 'fire') {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy *= 0.98;
                    this.vx *= 0.95;
                    this.flicker += this.flickerSpeed;
                } else if (this.type === 'earth') {
                    this.float += this.floatSpeed;
                    this.x += this.vx + Math.sin(this.float) * 2;
                    this.y += this.vy;
                    this.vy -= 0.02;
                } else if (this.type === 'shatter') {
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.rotation += this.rotSpeed;
                } else if (this.type === 'wood-break') {
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.rotation += this.rotSpeed;
                    this.vx *= 0.97;
                } else if (this.type === 'flood') {
                    this.wave += this.waveSpeed;
                    this.x += this.vx;
                    this.y += this.vy;
                } else if (this.type === 'burn') {
                    this.flicker += this.flickerSpeed;
                    this.burnStage += 0.008;
                    if (this.burnStage > 0.5) {
                        this.vy += 0.25;
                        this.x += Math.sin(this.flicker) * 0.5;
                    }
                    this.y += this.vy;
                } else if (this.type === 'earth-crack') {
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.95;
                }

                // Trail for certain types
                if (['fire', 'water', 'metal'].includes(this.type)) {
                    this.trail.push({x: this.x, y: this.y, opacity: this.opacity});
                    if (this.trail.length > 10) this.trail.shift();
                }
            }

            draw() {
                if (this.birthDelay > 0) return;

                particleCtx.save();

                // Draw character if transforming
                if (this.showChar && this.charToParticleProgress < 1) {
                    const charOpacity = (1 - this.charToParticleProgress) * this.opacity;
                    particleCtx.globalAlpha = charOpacity;
                    particleCtx.font = `${24 * (1 - this.charToParticleProgress * 0.5)}px Georgia`;
                    particleCtx.fillStyle = '#ffffff';
                    particleCtx.textAlign = 'center';
                    particleCtx.textBaseline = 'middle';
                    particleCtx.fillText(this.char, this.x, this.y);
                }

                // Draw particle
                const particleOpacity = this.showChar ? this.charToParticleProgress * this.opacity : this.opacity;
                particleCtx.globalAlpha = particleOpacity;

                // Draw trails
                if (this.trail.length > 1) {
                    particleCtx.beginPath();
                    particleCtx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        particleCtx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    particleCtx.strokeStyle = this.getColor();
                    particleCtx.lineWidth = this.size * 0.5;
                    particleCtx.stroke();
                }

                particleCtx.translate(this.x, this.y);
                this.drawShape();

                particleCtx.restore();
            }

            drawShape() {
                if (this.type === 'metal') {
                    const shimmerVal = Math.sin(this.shimmer) * 0.5 + 0.5;
                    const color = this.metalColor === 'silver' ?
                        `rgba(${192 + shimmerVal * 63}, ${192 + shimmerVal * 63}, ${192 + shimmerVal * 63}, ${this.opacity})` :
                        `rgba(255, ${215 + shimmerVal * 40}, 0, ${this.opacity})`;
                    particleCtx.beginPath();
                    particleCtx.arc(0, 0, this.size, 0, Math.PI * 2);
                    particleCtx.fillStyle = color;
                    particleCtx.shadowBlur = 20;
                    particleCtx.shadowColor = color;
                    particleCtx.fill();
                } else if (this.type === 'wood') {
                    particleCtx.beginPath();
                    particleCtx.arc(0, 0, this.size, 0, Math.PI * 2);
                    particleCtx.fillStyle = `rgba(34, 139, 34, ${this.opacity})`;
                    particleCtx.shadowBlur = 15;
                    particleCtx.shadowColor = `rgba(50, 205, 50, 0.5)`;
                    particleCtx.fill();
                } else if (this.type === 'water') {
                    particleCtx.beginPath();
                    particleCtx.arc(0, 0, this.size, 0, Math.PI * 2);
                    particleCtx.fillStyle = `rgba(100, 180, 255, ${this.opacity})`;
                    particleCtx.shadowBlur = 10;
                    particleCtx.shadowColor = 'rgba(100, 180, 255, 0.5)';
                    particleCtx.fill();
                } else if (this.type === 'fire') {
                    const intensity = 0.7 + Math.sin(this.flicker) * 0.3;
                    particleCtx.beginPath();
                    particleCtx.arc(0, 0, this.size * (1 + intensity * 0.5), 0, Math.PI * 2);
                    particleCtx.fillStyle = `hsla(${Math.random() * 60}, 100%, ${50 + intensity * 20}%, ${this.opacity})`;
                    particleCtx.shadowBlur = 25;
                    particleCtx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                    particleCtx.fill();
                } else if (this.type === 'earth') {
                    particleCtx.beginPath();
                    particleCtx.arc(0, 0, this.size, 0, Math.PI * 2);
                    particleCtx.fillStyle = `rgba(139, 69, 19, ${this.opacity})`;
                    particleCtx.shadowBlur = 10;
                    particleCtx.fill();
                } else if (this.type === 'shatter' || this.type === 'wood-break' || this.type === 'earth-crack') {
                    particleCtx.rotate(this.rotation || 0);
                    particleCtx.beginPath();
                    particleCtx.rect(-this.size, -this.size, this.size * 2, this.size * 2);
                    particleCtx.fillStyle = `rgba(200, 220, 255, ${this.opacity})`;
                    particleCtx.fill();
                } else if (this.type === 'flood') {
                    particleCtx.beginPath();
                    particleCtx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                    particleCtx.fillStyle = `rgba(30, 144, 255, ${this.opacity * 0.6})`;
                    particleCtx.fill();
                } else if (this.type === 'burn') {
                    if (this.burnStage < 0.3) {
                        particleCtx.beginPath();
                        particleCtx.arc(0, 0, this.size, 0, Math.PI * 2);
                        particleCtx.fillStyle = `hsla(${20 + Math.random() * 20}, 100%, 60%, ${this.opacity})`;
                        particleCtx.shadowBlur = 25;
                        particleCtx.fill();
                    } else {
                        particleCtx.beginPath();
                        particleCtx.arc(0, 0, this.size * 0.8, 0, Math.PI * 2);
                        particleCtx.fillStyle = `rgba(60, 60, 60, ${this.opacity * 0.8})`;
                        particleCtx.fill();
                    }
                }
            }

            getColor() {
                if (this.type === 'fire') return `hsla(30, 100%, 50%, ${this.opacity})`;
                if (this.type === 'water') return `rgba(100, 180, 255, ${this.opacity})`;
                if (this.type === 'metal') return `rgba(200, 200, 200, ${this.opacity})`;
                return `rgba(255, 255, 255, ${this.opacity})`;
            }
        }

        function createParticles(text, type) {
            particles = [];
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;

            // Screen-immersive particles
            const totalParticles = Math.floor((window.innerWidth * window.innerHeight) / 3000);

            // Text character particles
            const textChars = text.split('').filter(c => c.trim());
            textChars.forEach((c, i) => {
                const angle = (i / textChars.length) * Math.PI * 2;
                const baseX = cx + Math.cos(angle) * 150;
                const baseY = cy + Math.sin(angle) * 150;

                for (let j = 0; j < 3; j++) {
                    const offsetX = (Math.random() - 0.5) * 30;
                    const offsetY = (Math.random() - 0.5) * 30;
                    particles.push(new Particle(c, baseX + offsetX, baseY + offsetY, type));
                }
            });

            // Ambient particles
            const ambientCount = totalParticles - textChars.length * 3;
            for (let i = 0; i < ambientCount; i++) {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                particles.push(new Particle('', x, y, type));
            }
        }

        function animateParticles() {
            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            particles = particles.filter(p => {
                p.update();
                p.draw();
                return p.life > 0;
            });

            if (particles.length > 0) {
                requestAnimationFrame(animateParticles);
            }
        }

        // ============================================
        // PRAYER SYSTEM
        // ============================================
        function generatePrayer(language, mode) {
            currentPrayerMode = mode;

            const chinesePrayPrayers = {
                openings: ["Âú®‰∏áÁâ©ÊúâÁÅµÁöÑÂÆáÂÆô‰∏≠", "ÂΩìÂ§©Âú∞Áõ∏Ëøû‰πãÊó∂", "Âú®Ëá™ÁÑ∂ÁöÑÊÄÄÊä±Èáå", "‰∫éÂØÇÈùôÁöÑÂ±±Ê∞¥‰πãÈó¥", "Âú®Êó∂ÂÖâÁöÑÈïøÊ≤≥Èáå"],
                subjects: ["ÊàëÂêëÁü≥Â§¥Á•àÁ•∑", "ÊàëÂêëÊ†ëÊú®Á•àÁ•∑", "ÊàëÂêëÊµÅÊ∞¥Á•àÁ•∑", "ÊàëÂêëÈ£éÁ•àÁ•∑", "ÊàëÂêëÂ§ßÂú∞Á•àÁ•∑"],
                wishes: ["ÊÑøÂøÉÁÅµÂæóÂà∞Âπ≥Èùô", "ÊÑøÊô∫ÊÖßÂ¶ÇÊ≥âÊ∂åÁé∞", "ÊÑøË∫´ÂøÉÂíåË∞êÂÖ±Â≠ò", "ÊÑøÊâæÂà∞ÂÜÖÂú®ÁöÑÂÖâ", "ÊÑø‰∏é‰∏áÁâ©ÂêåÂú®"],
                closings: ["ÊÑüÊÅ©‰∏áÁâ©ÁöÑÊÅ©Ëµê", "ÊÑüË∞¢Ëá™ÁÑ∂ÁöÑÈ¶àËµ†", "ÊÑøÁÅµÊÄß‰πãÂÖâÁÖßËÄÄÂâçË∑Ø", "‰∏éËá™ÁÑ∂ÂêåË°åÔºå‰∏é‰∏áÁâ©ÂÖ±Áîü"]
            };

            const chineseReliefPrayers = {
                openings: ["Âú®ÈªëÊöóÊï£Âéª‰πãÊó∂", "ÂΩìË¥üËÉΩÈáèËÅöÈõÜ‰πãÂ§Ñ", "‰∫éÂÜÖÂøÉÊ∑∑Ê≤å‰πãÈôÖ", "Âú®Èò¥ÈúæÁ¨ºÁΩ©‰πãÊó∂"],
                subjects: ["ÊàëÂè¨Âî§ÂáÄÂåñ‰πãÂäõ", "ÊàëÂëºÂî§Ëß£ÊûÑ‰πãËÉΩ", "ÊàëÂºïÂØºÊ∂àËûç‰πãÂÖâ", "ÊàëÈáäÊîæÁ†¥Èô§‰πãÁÅ´"],
                wishes: ["Â∞ÜË¥üÈù¢ÊÉÖÁª™Âåñ‰∏∫ÁÅ∞ÁÉ¨", "ËÆ©ÁóõËã¶ËÆ∞ÂøÜÈöèÈ£éÊ∂àÊï£", "‰ΩøÈò¥ÊöóËÉΩÈáèÂàÜËß£Áì¶Ëß£", "‰ª§ÊâßÂøµÊû∑ÈîÅÁ≤âÁ¢éÁ†¥Ë£Ç"],
                closings: ["ÊÑøËΩªÁõàÂèñ‰ª£Ê≤âÈáç", "ÊÑøÂÖâÊòéÈ©±Êï£ÈªëÊöó", "ÊÑøÊñ∞ÁîüÊõø‰ª£ËÖêÊúΩ", "ÊÑøËá™Áî±ÂÜ≤Á†¥Áâ¢Á¨º"]
            };

            const englishPrayPrayers = {
                openings: ["In the universe where all things have spirit", "When heaven and earth unite", "In nature's embrace"],
                subjects: ["I pray to the stones", "I pray to the trees", "I pray to the flowing water", "I pray to the wind"],
                wishes: ["May my spirit find peace", "May wisdom flow like a spring", "May body and mind exist in harmony"],
                closings: ["Gratitude for the gifts of all things", "Thanks for nature's blessings", "May spiritual light illuminate the path"]
            };

            const englishReliefPrayers = {
                openings: ["As darkness begins to fade", "Where negative energy gathers", "In moments of inner chaos"],
                subjects: ["I summon the power of purification", "I invoke the force of deconstruction", "I channel the light of dissolution"],
                wishes: ["Turn negative emotions into ashes", "Let painful memories scatter in the wind", "Dissolve and decompose dark energy"],
                closings: ["May lightness replace heaviness", "May brightness dispel darkness", "May rebirth replace decay"]
            };

            let prayerElements;
            if (mode === 'pray') {
                prayerElements = language === 'zh' ? chinesePrayPrayers : englishPrayPrayers;
            } else {
                prayerElements = language === 'zh' ? chineseReliefPrayers : englishReliefPrayers;
            }

            const opening = prayerElements.openings[Math.floor(Math.random() * prayerElements.openings.length)];
            const subject = prayerElements.subjects[Math.floor(Math.random() * prayerElements.subjects.length)];
            const wish = prayerElements.wishes[Math.floor(Math.random() * prayerElements.wishes.length)];
            const closing = prayerElements.closings[Math.floor(Math.random() * prayerElements.closings.length)];

            const separator = language === 'zh' ? 'Ôºå' : ', ';
            const period = language === 'zh' ? '„ÄÇ' : '.';
            const prayer = `${opening}${separator}${subject}${separator}${wish}${period}${closing}${period}`;

            // Hide prayer bar
            document.getElementById('prayerBar').classList.add('hidden');

            // Show prayer text
            const prayerText = document.getElementById('prayerText');
            prayerText.querySelector('p').textContent = prayer;
            setTimeout(() => prayerText.classList.add('visible'), 100);

            // Show additional input
            setTimeout(() => {
                document.getElementById('additionalInput').classList.add('visible');
                // Show element selector
                document.getElementById('elementSelector').classList.add('visible');
            }, 800);
        }

        function connectWithElement(element) {
            const generatedText = document.getElementById('prayerText').querySelector('p').textContent;
            const additionalInput = document.getElementById('additionalPrayer').value.trim();
            const combinedText = additionalInput ? generatedText + ' ' + additionalInput : generatedText;

            // Hide UI
            document.getElementById('prayerText').classList.remove('visible');
            document.getElementById('additionalInput').classList.remove('visible');
            document.getElementById('elementSelector').classList.remove('visible');

            // Show pray again button
            setTimeout(() => {
                document.getElementById('prayAgainButton').classList.add('visible');
            }, 500);

            // Launch comet
            launchComet();

            // Map element to effect type
            let effectType;
            if (currentPrayerMode === 'pray') {
                const prayMap = { metal: 'metal', wood: 'wood', water: 'water', fire: 'fire', earth: 'earth' };
                effectType = prayMap[element];
            } else {
                const reliefMap = { metal: 'shatter', wood: 'wood-break', water: 'flood', fire: 'burn', earth: 'earth-crack' };
                effectType = reliefMap[element];
            }

            // Create particles
            createParticles(combinedText, effectType);
            animateParticles();
        }

        function restartPrayer() {
            // Hide pray again button
            document.getElementById('prayAgainButton').classList.remove('visible');

            // Clear inputs
            document.getElementById('additionalPrayer').value = '';
            document.getElementById('prayerText').querySelector('p').textContent = '';

            // Show prayer bar
            setTimeout(() => {
                document.getElementById('prayerBar').classList.remove('hidden');
            }, 300);

            // Clear particles
            particles = [];
        }

        // ============================================
        // AUDIO
        // ============================================
        function initAudio() {
            const audio = document.getElementById('backgroundAudio');

            // Try to autoplay
            audio.play().catch(() => {
                // If autoplay fails, play on first user interaction
                document.addEventListener('pointerdown', () => {
                    audio.play();
                }, { once: true });
            });
        }

        // ============================================
        // ELEMENT SELECTOR INTERACTIONS
        // ============================================
        function initElementSelector() {
            const emojis = document.querySelectorAll('.element-emoji');
            emojis.forEach(emoji => {
                emoji.addEventListener('click', function() {
                    const element = this.getAttribute('data-element');
                    connectWithElement(element);
                });
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        window.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            initParticleCanvas();
            initAudio();
            initElementSelector();
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Spiritual Space</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            overflow: hidden;
        }

        .prayer-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 50%, #16213e 100%);
        }

        #backgroundVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
        }

        /* Pray Again button on top right */
        .pray-again-button {
            position: absolute;
            top: 2rem;
            right: 2rem;
            z-index: 10;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            display: none;
            opacity: 0;
        }

        .pray-again-button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .prayer-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4;
            padding: 2rem;
            transition: opacity 0.8s ease;
        }

        .prayer-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Darken video overlay for better particle visibility */
        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 2;
            pointer-events: none;
        }

        .prayer-content {
            text-align: center;
            transition: all 0.5s ease;
        }

        .prayer-controls {
            margin: 0;
            transition: opacity 0.3s ease;
        }

        .prayer-button {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 0.5rem 1.5rem;
            font-size: 0.9rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 400;
            backdrop-filter: blur(10px);
        }

        .prayer-button:hover {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }

        .prayer-button:active {
            transform: scale(0.98);
        }

        .prayer-text {
            padding: 1.5rem;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            max-width: 700px;
            margin: 0 auto;
        }

        .prayer-text p {
            color: #ffffff;
            line-height: 2;
            font-size: 1.3rem;
            margin: 0;
            font-style: italic;
            text-shadow: 0 3px 8px rgba(0,0,0,0.9);
            font-weight: 400;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .prayer-container {
                height: 100vh;
                min-height: 500px;
            }

            .prayer-content {
                padding: 2rem 1.5rem;
                max-width: 90%;
            }

            .prayer-button {
                padding: 0.8rem 2rem;
                font-size: 1rem;
            }

            .prayer-text p {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="prayer-container">
        <video id="backgroundVideo" autoplay loop muted playsinline>
            <source src="video.mp4" type="video/mp4">
        </video>
        <div class="video-overlay"></div>
        <canvas id="particleCanvas"></canvas>

        <button id="prayAgainButton" class="pray-again-button" onclick="restartPrayer()">Pray Again</button>

        <div class="prayer-overlay" id="prayerOverlay">
            <div class="prayer-content" id="prayerContent">
                <div class="prayer-controls" id="prayButtons" style="display: flex; gap: 1.5rem; flex-wrap: wrap; justify-content: center; align-items: flex-start;">
                    <!-- Pray Group -->
                    <div style="display: flex; flex-direction: column; gap: 0.5rem; background: rgba(255, 255, 255, 0.1); padding: 1rem; border-radius: 15px; backdrop-filter: blur(10px);">
                        <button onclick="generatePrayer('en', 'pray')" class="prayer-button">Pray</button>
                        <button onclick="generatePrayer('zh', 'pray')" class="prayer-button">Á•àÁ•∑</button>
                    </div>

                    <!-- Relief Group -->
                    <div style="display: flex; flex-direction: column; gap: 0.5rem; background: rgba(255, 255, 255, 0.1); padding: 1rem; border-radius: 15px; backdrop-filter: blur(10px);">
                        <button onclick="generatePrayer('en', 'relief')" class="prayer-button">Relief</button>
                        <button onclick="generatePrayer('zh', 'relief')" class="prayer-button">Ê∂àÁÅæ</button>
                    </div>
                </div>

                <div id="prayerText" class="prayer-text" style="display: none;">
                    <p></p>
                </div>

                <div id="additionalInput" style="display: none; margin-top: 1rem;">
                    <input type="text" id="additionalPrayer" placeholder="Add your own words..." style="padding: 0.5rem 1rem; width: 300px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.5); background: rgba(255,255,255,0.15); color: white; backdrop-filter: blur(10px); font-size: 0.9rem;">
                </div>

                <!-- Five Elements Selection - Circular Wheel -->
                <div id="elementWheel" style="display: none; margin-top: 2rem; position: relative; width: 200px; height: 200px; margin-left: auto; margin-right: auto;">
                    <div class="element-emoji" data-element="metal" style="position: absolute; font-size: 2rem; cursor: pointer; transition: all 0.3s ease;">üí∞</div>
                    <div class="element-emoji" data-element="wood" style="position: absolute; font-size: 2rem; cursor: pointer; transition: all 0.3s ease;">üå≥</div>
                    <div class="element-emoji" data-element="water" style="position: absolute; font-size: 2rem; cursor: pointer; transition: all 0.3s ease;">üíß</div>
                    <div class="element-emoji" data-element="fire" style="position: absolute; font-size: 2rem; cursor: pointer; transition: all 0.3s ease;">üî•</div>
                    <div class="element-emoji" data-element="earth" style="position: absolute; font-size: 2rem; cursor: pointer; transition: all 0.3s ease;">‚õ∞Ô∏è</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mouse tracking for speed modulation (Relief mode only)
        let mouseX = 0, mouseY = 0, prevMouseX = 0, prevMouseY = 0;
        let mouseSpeed = 0;
        let speedMultiplier = 0; // Start completely static (no movement)

        // Element wheel rotation
        let wheelRotation = 0;
        let wheelRotating = true;
        let wheelAnimationId = null;

        // Particle System
        let canvas, ctx, particles = [], animationId;
        let currentPrayerMode = 'pray';

        // Initialize on load
        window.addEventListener('load', () => {
            initCanvas();
            document.addEventListener('mousemove', trackMouseSpeed);
        });

        class Particle {
            constructor(char, x, y, type, charIndex) {
                this.char = char;
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.type = type;
                this.charIndex = charIndex;
                this.size = Math.random() * 3 + 2;
                this.opacity = 1;
                this.life = 1;
                this.trail = [];
                this.birthDelay = 0; // Frames to wait before becoming visible
                this.showChar = false; // Whether to show as character initially
                this.charToParticleProgress = 0; // 0 = character, 1 = particle
                this.age = 0; // How long the particle has been alive

                if (type === 'fire') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = -Math.random() * 4 - 2;
                    this.flicker = Math.random() * Math.PI;
                    this.flickerSpeed = Math.random() * 0.3 + 0.2;
                    this.hue = Math.random() * 60;
                } else if (type === 'water') {
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = Math.random() * 0.5 - 2;
                    this.wave = Math.random() * Math.PI * 2;
                    this.waveSpeed = Math.random() * 0.15 + 0.1;
                    this.waveAmplitude = Math.random() * 4 + 2;
                } else if (type === 'metal') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.spiralRadius = Math.random() * 20;
                    this.spiralSpeed = (Math.random() - 0.5) * 0.1;
                    this.upwardSpeed = Math.random() * 2 + 1;
                    this.shimmer = Math.random() * Math.PI * 2;
                    this.shimmerSpeed = Math.random() * 0.2 + 0.1;
                    this.metalColor = Math.random() > 0.5 ? 'silver' : 'gold';
                    this.expansion = 1;
                    this.expansionSpeed = Math.random() * 0.015 + 0.01;
                } else if (type === 'wood') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = -Math.random() * 2.5 - 1.5;
                    this.swirl = Math.random() * Math.PI * 2;
                    this.swirlSpeed = Math.random() * 0.15 + 0.1;
                    this.swirlRadius = Math.random() * 3 + 2;
                    this.growth = 1;
                    this.growthSpeed = Math.random() * 0.02 + 0.01;
                    this.branchAngle = (Math.random() - 0.5) * 0.5;
                } else if (type === 'earth') {
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = -Math.random() * 2 - 1;
                    this.float = Math.random() * Math.PI * 2;
                    this.floatSpeed = Math.random() * 0.08 + 0.05;
                    this.floatAmplitude = Math.random() * 2 + 1;
                    this.earthColor = Math.floor(Math.random() * 3);
                    this.expansion = 1;
                    this.expansionSpeed = Math.random() * 0.02 + 0.01;
                } else if (type === 'wood-break') {
                    this.vx = (Math.random() - 0.5) * 1.5;
                    this.vy = Math.random() * 0.5;
                    this.gravity = 0.08;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotSpeed = (Math.random() - 0.5) * 0.08;
                    this.length = Math.random() * 10 + 5;
                    this.drift = Math.random() * Math.PI * 2;
                    this.driftSpeed = Math.random() * 0.04 + 0.02;
                } else if (type === 'flood') {
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = Math.random() * 0.6 + 0.3;
                    this.wave = Math.random() * Math.PI * 2;
                    this.waveSpeed = Math.random() * 0.08 + 0.05;
                } else if (type === 'burn') {
                    this.vx = (Math.random() - 0.5) * 0.8;
                    this.vy = 0;
                    this.burnStage = 0;
                    this.flicker = Math.random() * Math.PI;
                    this.flickerSpeed = Math.random() * 0.25 + 0.15;
                    this.fallSpeed = Math.random() * 0.25 + 0.15;
                    this.drift = Math.random() * Math.PI * 2;
                    this.driftSpeed = Math.random() * 0.04 + 0.02;
                } else if (type === 'earth-crack') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.speed = Math.random() * 0.8 + 0.3;
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.gravity = 0.05;
                    this.settled = false;
                } else if (type === 'shatter') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.gravity = 0.3;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotSpeed = (Math.random() - 0.5) * 0.3;
                    this.edges = Math.floor(Math.random() * 3) + 3;
                } else if (type === 'smoke') {
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = Math.random() * 0.5 + 0.3;
                    this.expansion = 1;
                    this.expansionSpeed = Math.random() * 0.03 + 0.02;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotSpeed = (Math.random() - 0.5) * 0.05;
                    this.drift = Math.random() * Math.PI * 2;
                    this.driftSpeed = Math.random() * 0.08 + 0.05;
                    this.fadeStage = 0;
                    this.fadeSpeed = Math.random() * 0.006 + 0.004;
                }
            }

            update() {
                // Handle birth delay
                if (this.birthDelay > 0) {
                    this.birthDelay--;
                    return; // Don't update or show particle yet
                }

                this.age++;

                // Gradual transformation from character to particle (over 90 frames / 1.5 seconds)
                if (this.showChar && this.charToParticleProgress < 1) {
                    this.charToParticleProgress += 0.011; // Reach 1.0 after ~90 frames
                }

                if (this.type === 'fire') {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy *= 0.98;
                    this.vx *= 0.95;
                    this.flicker += this.flickerSpeed;
                } else if (this.type === 'water') {
                    this.wave += this.waveSpeed;
                    this.x += this.vx + Math.sin(this.wave) * this.waveAmplitude;
                    this.y += this.vy;
                } else if (this.type === 'metal') {
                    this.angle += this.spiralSpeed;
                    this.y -= this.upwardSpeed;
                    this.x += Math.cos(this.angle) * this.spiralRadius;
                    this.spiralRadius += 0.3;
                    this.shimmer += this.shimmerSpeed;
                    this.expansion += this.expansionSpeed;
                } else if (this.type === 'wood') {
                    this.swirl += this.swirlSpeed;
                    this.x += this.vx + Math.cos(this.swirl) * this.swirlRadius;
                    this.y += this.vy;
                    this.vy -= 0.03;
                    this.growth += this.growthSpeed;
                    this.branchAngle += 0.02;
                    this.swirlRadius += 0.05;
                } else if (this.type === 'earth') {
                    this.float += this.floatSpeed;
                    this.x += this.vx + Math.sin(this.float) * this.floatAmplitude;
                    this.y += this.vy;
                    this.vy -= 0.02;
                    this.expansion += this.expansionSpeed;
                } else if (this.type === 'wood-break') {
                    this.vy += this.gravity * speedMultiplier;
                    this.x += this.vx * speedMultiplier;
                    this.y += this.vy * speedMultiplier;
                    this.rotation += this.rotSpeed * speedMultiplier;
                    this.vx *= 0.97;
                } else if (this.type === 'flood') {
                    this.wave += this.waveSpeed * speedMultiplier;
                    this.x += this.vx * speedMultiplier;
                    this.y += this.vy * speedMultiplier;
                } else if (this.type === 'burn') {
                    this.flicker += this.flickerSpeed * speedMultiplier;
                    this.burnStage += 0.008 * speedMultiplier;

                    if (this.burnStage < 0.3) {
                        this.vx += (Math.random() - 0.5) * 0.1 * speedMultiplier;
                        this.vy += (Math.random() - 0.5) * 0.1 * speedMultiplier;
                        this.vx *= 0.95;
                        this.vy *= 0.95;
                    } else if (this.burnStage < 0.5) {
                        this.vy += this.fallSpeed * 0.5 * speedMultiplier;
                        this.drift += this.driftSpeed * speedMultiplier;
                        this.x += Math.sin(this.drift) * 0.3 * speedMultiplier;
                    } else {
                        this.vy = (this.fallSpeed + (this.burnStage - 0.5) * 0.5) * speedMultiplier;
                        this.drift += this.driftSpeed * speedMultiplier;
                        this.x += Math.sin(this.drift) * 0.5 * speedMultiplier;
                    }

                    this.x += this.vx * speedMultiplier;
                    this.y += this.vy * speedMultiplier;
                } else if (this.type === 'earth-crack') {
                    this.vy += this.gravity * speedMultiplier;
                    this.x += this.vx * speedMultiplier;
                    this.y += this.vy * speedMultiplier;
                    this.vx *= 0.95;
                    if (this.y > canvas.height - 30) {
                        this.settled = true;
                        this.vy = 0;
                        this.vx = 0;
                    }
                } else if (this.type === 'shatter') {
                    this.vy += this.gravity;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.rotation += this.rotSpeed;
                } else if (this.type === 'smoke') {
                    this.drift += this.driftSpeed;
                    this.x += this.vx + Math.sin(this.drift) * 1.5;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.expansion += this.expansionSpeed;
                    this.rotation += this.rotSpeed;
                    this.fadeStage += this.fadeSpeed;
                    this.vy *= 0.99;
                }

                if (this.type === 'fire' || this.type === 'water') {
                    this.trail.push({x: this.x, y: this.y, opacity: this.opacity});
                    if (this.trail.length > 10) this.trail.shift();
                }

                this.life -= 0.0015; // Slower fade (was 0.006) - particles last ~5.5 seconds
                this.opacity = Math.max(0, this.life);
            }

            draw() {
                // Don't draw if still in birth delay
                if (this.birthDelay > 0) return;

                ctx.save();

                // Draw character first if it's transforming
                if (this.showChar && this.charToParticleProgress < 1) {
                    const charOpacity = (1 - this.charToParticleProgress) * this.opacity;
                    ctx.globalAlpha = charOpacity;
                    ctx.font = `${24 * (1 - this.charToParticleProgress * 0.5)}px Georgia`; // Shrink as it transforms
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.char, this.x, this.y);
                    ctx.restore();
                    ctx.save();
                }

                // Draw particle effects with increasing opacity as transformation progresses
                const particleOpacity = this.showChar ? this.charToParticleProgress * this.opacity : this.opacity;
                ctx.globalAlpha = particleOpacity;

                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.strokeStyle = this.getColor();
                    ctx.lineWidth = this.size * 0.5;
                    ctx.globalAlpha = this.opacity * 0.3;
                    ctx.stroke();
                }

                // globalAlpha already set above based on transformation progress
                ctx.translate(this.x, this.y);

                if (this.type === 'fire') {
                    const intensity = 0.7 + Math.sin(this.flicker) * 0.3;
                    const hue = this.hue * intensity;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * (1 + intensity * 0.5), 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${hue}, 100%, ${50 + intensity * 20}%, ${this.opacity})`;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.8)`;
                    ctx.fill();
                } else if (this.type === 'water') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(100, 180, 255, ${this.opacity * 0.8})`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(100, 180, 255, 0.5)';
                    ctx.fill();
                } else if (this.type === 'metal') {
                    const shimmerVal = Math.sin(this.shimmer) * 0.5 + 0.5;
                    const color = this.metalColor === 'silver' ?
                        `rgba(${192 + shimmerVal * 63}, ${192 + shimmerVal * 63}, ${192 + shimmerVal * 63}, ${this.opacity})` :
                        `rgba(255, ${215 + shimmerVal * 40}, 0, ${this.opacity})`;

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * this.expansion, 0, Math.PI * 2);
                    ctx.fillStyle = color.replace(this.opacity.toString(), (this.opacity * 0.3).toString());
                    ctx.shadowBlur = 30 * this.expansion;
                    ctx.shadowColor = color;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * (1 + this.expansion * 0.3), 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = color;
                    ctx.fill();
                } else if (this.type === 'wood') {
                    ctx.save();
                    ctx.rotate(this.branchAngle);

                    const leafSize = this.size * (1 + this.growth * 0.5);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, leafSize * 0.6, leafSize * 1.2, 0, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(34, 139, 34, ${this.opacity * 0.7})`;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(50, 205, 50, ${this.opacity * 0.5})`;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.ellipse(0, 0, leafSize * 0.8, leafSize * 1.4, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(50, 205, 50, ${this.opacity * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.restore();
                } else if (this.type === 'earth') {
                    const earthColors = [
                        `rgba(139, 69, 19, ${this.opacity})`,
                        `rgba(160, 82, 45, ${this.opacity})`,
                        `rgba(210, 180, 140, ${this.opacity})`
                    ];

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * this.expansion * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = earthColors[this.earthColor].replace(this.opacity.toString(), (this.opacity * 0.2).toString());
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * (1 + this.expansion * 0.2), 0, Math.PI * 2);
                    ctx.fillStyle = earthColors[this.earthColor];
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = earthColors[this.earthColor];
                    ctx.fill();
                } else if (this.type === 'wood-break') {
                    ctx.rotate(this.rotation);
                    ctx.beginPath();
                    ctx.rect(-this.size * 0.5, -this.length / 2, this.size, this.length);
                    ctx.fillStyle = `rgba(139, 69, 19, ${this.opacity})`;
                    ctx.strokeStyle = `rgba(101, 67, 33, ${this.opacity})`;
                    ctx.lineWidth = 1;
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'flood') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(30, 144, 255, ${this.opacity * 0.6})`;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = 'rgba(30, 144, 255, 0.4)';
                    ctx.fill();
                } else if (this.type === 'burn') {
                    const intensity = 0.5 + Math.sin(this.flicker) * 0.5;

                    if (this.burnStage < 0.3) {
                        const fireHue = 20 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * (1 + intensity * 0.5), 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${fireHue}, 100%, ${60 + intensity * 20}%, ${this.opacity})`;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = `hsla(${fireHue}, 100%, 50%, 0.8)`;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * (2 + intensity), 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${fireHue}, 100%, 50%, ${this.opacity * 0.2})`;
                        ctx.fill();
                    } else if (this.burnStage < 0.5) {
                        const burnProgress = (this.burnStage - 0.3) / 0.2;
                        const burnHue = 20 * (1 - burnProgress);
                        const saturation = 100 * (1 - burnProgress);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${burnHue}, ${saturation}%, 40%, ${this.opacity})`;
                        ctx.shadowBlur = 15 * (1 - burnProgress);
                        ctx.shadowColor = `hsla(${burnHue}, ${saturation}%, 40%, 0.5)`;
                        ctx.fill();
                    } else {
                        const ashDarkness = 40 + (this.burnStage - 0.5) * 40;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 0.8, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${ashDarkness}, ${ashDarkness}, ${ashDarkness}, ${this.opacity * 0.8})`;
                        ctx.shadowBlur = 3;
                        ctx.shadowColor = `rgba(${ashDarkness}, ${ashDarkness}, ${ashDarkness}, 0.4)`;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${ashDarkness + 20}, ${ashDarkness + 20}, ${ashDarkness + 20}, ${this.opacity * 0.15})`;
                        ctx.fill();
                    }
                } else if (this.type === 'earth-crack') {
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const x = Math.cos(angle) * this.size * 1.5;
                        const y = Math.sin(angle) * this.size * 1.5;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fillStyle = `rgba(101, 67, 33, ${this.opacity})`;
                    ctx.strokeStyle = `rgba(139, 69, 19, ${this.opacity})`;
                    ctx.lineWidth = 1;
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'shatter') {
                    ctx.rotate(this.rotation);
                    ctx.beginPath();
                    for (let i = 0; i < this.edges; i++) {
                        const angle = (i / this.edges) * Math.PI * 2;
                        const x = Math.cos(angle) * this.size * 2;
                        const y = Math.sin(angle) * this.size * 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.strokeStyle = `rgba(200, 220, 255, ${this.opacity})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (this.type === 'smoke') {
                    ctx.rotate(this.rotation);
                    ctx.scale(this.expansion, this.expansion);

                    const smokeDarkness = 60 + this.fadeStage * 100;
                    const smokeAlpha = this.opacity * (0.7 - this.fadeStage * 0.5);

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${smokeDarkness + 30}, ${smokeDarkness + 30}, ${smokeDarkness + 30}, ${smokeAlpha * 0.15})`;
                    ctx.filter = `blur(${5 + this.expansion * 2}px)`;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${smokeDarkness + 15}, ${smokeDarkness + 15}, ${smokeDarkness + 15}, ${smokeAlpha * 0.35})`;
                    ctx.filter = `blur(${3 + this.expansion}px)`;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${smokeDarkness}, ${smokeDarkness}, ${smokeDarkness}, ${smokeAlpha * 0.6})`;
                    ctx.filter = `blur(${2 + this.expansion * 0.5}px)`;
                    ctx.fill();
                }

                ctx.restore();
            }

            getColor() {
                if (this.type === 'fire') {
                    return `hsla(${this.hue}, 100%, 50%, ${this.opacity})`;
                } else if (this.type === 'water') {
                    return `rgba(100, 180, 255, ${this.opacity})`;
                }
                return `rgba(255, 255, 255, ${this.opacity})`;
            }
        }

        function initCanvas() {
            canvas = document.getElementById('particleCanvas');
            if (!canvas) return;
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function createParticles(text, type) {
            particles = [];
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create screen-immersive particles - based on screen area, not character count
            const totalParticles = Math.floor((canvas.width * canvas.height) / 3000); // ~1 particle per 3000 pixels

            // First create text character particles in the center
            const textChars = text.split('').filter(c => c.trim());
            const charParticles = textChars.length * 3; // 3 particles per character initially

            // Place character-based particles in a circle formation
            textChars.forEach((c, i) => {
                const angle = (i / textChars.length) * Math.PI * 2;
                const baseX = cx + Math.cos(angle) * 150;
                const baseY = cy + Math.sin(angle) * 150;

                for (let j = 0; j < 3; j++) {
                    const offsetX = (Math.random() - 0.5) * 30;
                    const offsetY = (Math.random() - 0.5) * 30;
                    const particle = new Particle(c, baseX + offsetX, baseY + offsetY, type, i);
                    particle.birthDelay = Math.random() * 60; // Gradual appearance over 60 frames (~1 second)
                    particle.showChar = true; // Start as character
                    particle.charToParticleProgress = 0; // 0 = character, 1 = full particle
                    particles.push(particle);
                }
            });

            // Then fill the rest of the screen with ambient particles (no characters)
            const ambientParticles = totalParticles - charParticles;
            for (let i = 0; i < ambientParticles; i++) {
                // Random position across entire screen
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const particle = new Particle('', x, y, type, -1);
                particle.birthDelay = Math.random() * 120; // Staggered birth over 2 seconds
                particle.showChar = false; // No character, pure particle
                particle.charToParticleProgress = 1; // Already a particle
                particles.push(particle);
            }
        }

        function trackMouseSpeed(e) {
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;

            const dx = mouseX - prevMouseX;
            const dy = mouseY - prevMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            mouseSpeed = mouseSpeed * 0.2 + distance * 0.8; // Very responsive to mouse
            speedMultiplier = Math.min(mouseSpeed / 50, 3.0); // Higher sensitivity and max speed
        }

        function animateElementWheel() {
            if (!wheelRotating) return;

            const wheel = document.getElementById('elementWheel');
            if (!wheel || wheel.style.display === 'none') return;

            wheelRotation += 0.01;

            const emojis = wheel.querySelectorAll('.element-emoji');
            const radius = 80;
            const centerX = 100;
            const centerY = 100;

            emojis.forEach((emoji, index) => {
                const angle = wheelRotation + (index * (Math.PI * 2) / 5);
                const x = centerX + Math.cos(angle) * radius - 16;
                const y = centerY + Math.sin(angle) * radius - 16;

                emoji.style.left = x + 'px';
                emoji.style.top = y + 'px';
            });

            wheelAnimationId = requestAnimationFrame(animateElementWheel);
        }

        function initElementWheelInteractions() {
            const emojis = document.querySelectorAll('.element-emoji');
            emojis.forEach(emoji => {
                emoji.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const element = this.getAttribute('data-element');
                    wheelRotating = false;
                    if (wheelAnimationId) cancelAnimationFrame(wheelAnimationId);
                    connectWithElement(element);
                });

                emoji.addEventListener('mouseenter', function() {
                    wheelRotating = false;
                    if (wheelAnimationId) cancelAnimationFrame(wheelAnimationId);
                    this.style.transform = 'scale(1.5)';
                    this.style.filter = 'drop-shadow(0 0 15px rgba(255,255,255,1))';
                });

                emoji.addEventListener('mouseleave', function() {
                    wheelRotating = true;
                    animateElementWheel();
                    this.style.transform = 'scale(1)';
                    this.style.filter = 'none';
                });
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            mouseSpeed *= 0.80; // Faster decay = quicker stop
            speedMultiplier = Math.min(mouseSpeed / 50, 3.0); // Match the tracking sensitivity

            particles = particles.filter(p => {
                p.update();
                p.draw();
                return p.life > 0;
            });
            if (particles.length > 0) requestAnimationFrame(animate);
        }

        function generatePrayer(language, mode) {
            currentPrayerMode = mode;

            const chinesePrayPrayers = {
                openings: ["Âú®‰∏áÁâ©ÊúâÁÅµÁöÑÂÆáÂÆô‰∏≠", "ÂΩìÂ§©Âú∞Áõ∏Ëøû‰πãÊó∂", "Âú®Ëá™ÁÑ∂ÁöÑÊÄÄÊä±Èáå", "‰∫éÂØÇÈùôÁöÑÂ±±Ê∞¥‰πãÈó¥", "Âú®Êó∂ÂÖâÁöÑÈïøÊ≤≥Èáå", "Âú®Êô®Êõ¶ÂàùÁé∞‰πãÈôÖ", "ÂΩìÊúàÂÖâÊ¥íÊª°Â§ßÂú∞", "Âú®ÂõõÂ≠£ËΩÆËΩ¨‰πã‰∏≠", "‰∫éÈùôË∞ßÁöÑÊ∑±Â§ú", "Âú®‰∏áÁ±Å‰ø±ÂØÇÊó∂", "ÂΩìÂøÉÁÅµÂÆÅÈùô‰πãÂàª", "Âú®Â§©Âú∞‰∫§ËûçÂ§Ñ"],
                subjects: ["ÊàëÂêëÁü≥Â§¥Á•àÁ•∑", "ÊàëÂêëÊ†ëÊú®Á•àÁ•∑", "ÊàëÂêëÊµÅÊ∞¥Á•àÁ•∑", "ÊàëÂêëÈ£éÁ•àÁ•∑", "ÊàëÂêëÂ§ßÂú∞Á•àÁ•∑", "ÊàëÂêëÊòüËæ∞Á•àÁ•∑", "ÊàëÂêëÂ±±Â∑ùÁ•àÁ•∑", "ÊàëÂêë‰∫ëÊúµÁ•àÁ•∑", "ÊàëÂêëÈõ®Èú≤Á•àÁ•∑", "ÊàëÂêëËä±ËçâÁ•àÁ•∑", "ÊàëÂêëÊó•ÊúàÁ•àÁ•∑", "ÊàëÂêë‰∏áÁâ©Á•àÁ•∑"],
                wishes: ["ÊÑøÂøÉÁÅµÂæóÂà∞Âπ≥Èùô", "ÊÑøÊô∫ÊÖßÂ¶ÇÊ≥âÊ∂åÁé∞", "ÊÑøË∫´ÂøÉÂíåË∞êÂÖ±Â≠ò", "ÊÑøÊâæÂà∞ÂÜÖÂú®ÁöÑÂÖâ", "ÊÑø‰∏é‰∏áÁâ©ÂêåÂú®", "ÊÑøÊÑüÂèóÂà∞ÁîüÂëΩÁöÑËøûÊé•", "ÊÑøÁÅµÈ≠ÇÂæóÂà∞ÊªãÂÖª", "ÊÑøËé∑ÂæóÂÜÖÂøÉÁöÑÂÆâÂÆÅ", "ÊÑøÊÑüÁü•Ëá™ÁÑ∂ÁöÑÂëºÂê∏", "ÊÑøÂøÉ‰∏≠ÂÖÖÊª°Áà±‰∏éÊÖàÊÇ≤", "ÊÑøËßâÁü•ÁîüÂëΩÁöÑÁæéÂ•Ω", "ÊÑø‰ΩìÊÇü‰∏áÁâ©ÁöÑÁÅµÊÄß"],
                closings: ["ÊÑüÊÅ©‰∏áÁâ©ÁöÑÊÅ©Ëµê", "ÊÑüË∞¢Ëá™ÁÑ∂ÁöÑÈ¶àËµ†", "ÊÑøÁÅµÊÄß‰πãÂÖâÁÖßËÄÄÂâçË∑Ø", "‰∏éËá™ÁÑ∂ÂêåË°åÔºå‰∏é‰∏áÁâ©ÂÖ±Áîü", "ÂøÉÊÄÄÊï¨ÁïèÔºåÊÑüÊÅ©ÂΩì‰∏ã", "ÊÑøÁîüÂëΩ‰πãÂÖâÊ∞∏‰∏çÁÜÑÁÅ≠", "‰∏éÂ§©Âú∞ÂÖ±È∏£Ôºå‰∏é‰∏áÁâ©‰∏∫Âèã", "ÊÑüÊÅ©Ëøô‰∏ÄÂàªÁöÑÂ≠òÂú®", "ÊÑøÂøÉ‰∏≠Â∏∏ÊÄÄÊÑüÊøÄ", "‰∏áÁâ©ÊúâÁÅµÔºåÁöÜÂÄºÂæóÊï¨Áïè"]
            };

            const chineseReliefPrayers = {
                openings: ["Âú®ÈªëÊöóÊï£Âéª‰πãÊó∂", "ÂΩìË¥üËÉΩÈáèËÅöÈõÜ‰πãÂ§Ñ", "‰∫éÂÜÖÂøÉÊ∑∑Ê≤å‰πãÈôÖ", "Âú®Èò¥ÈúæÁ¨ºÁΩ©‰πãÊó∂", "ÂΩìÂøÉÈ≠î‰æµÊâ∞‰πãÂàª", "Âú®ÁóõËã¶Áº†Áªï‰πãÈôÖ", "‰∫éËø∑Ëå´Âõ∞È°ø‰πãÊó∂", "ÂΩìÊÄ®ÂøµÂ†ÜÁßØ‰πãÂ§Ñ", "Âú®ÊâßÂøµÊùüÁºö‰πãÊó∂", "‰∫éÊÅêÊÉßÂçáËµ∑‰πãÂàª", "ÂΩìÁÑ¶ËôëÂº•Êº´‰πãÈôÖ", "Âú®Âàõ‰º§Êú™ÊÑà‰πãÊó∂"],
                subjects: ["ÊàëÂè¨Âî§ÂáÄÂåñ‰πãÂäõ", "ÊàëÂëºÂî§Ëß£ÊûÑ‰πãËÉΩ", "ÊàëÂºïÂØºÊ∂àËûç‰πãÂÖâ", "ÊàëÈáäÊîæÁ†¥Èô§‰πãÁÅ´", "ÊàëÂêØÂä®Ê∂§Ëç°‰πãÈ£é", "ÊàëÊøÄÂèëÁ≤âÁ¢é‰πãÈõ∑", "ÊàëÂî§ÈÜíËΩ¨Âåñ‰πãÊ∞¥", "ÊàëÂºÄÂêØÂâ•Á¶ª‰πãÂàÉ", "ÊàëÁÇπÁáÉÁÑöÁÉß‰πãÁÑ∞", "ÊàëÂèëÂä®ÈúáÁ¢é‰πãÂäõ", "ÊàëËøêËΩ¨Ê¥óÊ∂§‰πãÊµÅ", "ÊàëÊñΩÂ±ïÂ¥©Ëß£‰πãÊúØ"],
                wishes: ["Â∞ÜË¥üÈù¢ÊÉÖÁª™Âåñ‰∏∫ÁÅ∞ÁÉ¨", "ËÆ©ÁóõËã¶ËÆ∞ÂøÜÈöèÈ£éÊ∂àÊï£", "‰ΩøÈò¥ÊöóËÉΩÈáèÂàÜËß£Áì¶Ëß£", "‰ª§ÊâßÂøµÊû∑ÈîÅÁ≤âÁ¢éÁ†¥Ë£Ç", "ËÆ©ÊÄ®ÊÅ®‰πãÂøÉÊ∫∂Ëß£ÂáÄÂåñ", "‰ΩøÊÅêÊÉß‰πãÊ∫êÁáÉÁÉßÊÆÜÂ∞Ω", "‰ª§ÁÑ¶Ëôë‰πãÊ†πËøûÊ†πÊãîËµ∑", "ËÆ©ÊÇ≤‰º§‰πãÈõæÁÉüÊ∂à‰∫ëÊï£", "‰ΩøÂàõ‰º§‰πãÈìæÂΩªÂ∫ïÊñ≠Ë£Ç", "‰ª§Ëø∑ÊÉò‰πãÂøµÂΩí‰∫éËôöÊó†", "ËÆ©ÊùüÁºö‰πãÂäõÂúüÂ¥©Áì¶Ëß£", "‰ΩøË¥üÊãÖ‰πãÈáçÊ≤âÂÖ•Ê∑±Ê∏ä"],
                closings: ["ÊÑøËΩªÁõàÂèñ‰ª£Ê≤âÈáç", "ÊÑøÂÖâÊòéÈ©±Êï£ÈªëÊöó", "ÊÑøÊñ∞ÁîüÊõø‰ª£ËÖêÊúΩ", "ÊÑøËá™Áî±ÂÜ≤Á†¥Áâ¢Á¨º", "ÊÑøÊ∏ÖÊòéÊ¥óÂáÄÊ∑∑Ê≤å", "ÊÑøÂπ≥ÈùôÊäöÂπ≥Ê≥¢Êæú", "ÊÑøÈáçÁîüË∂ÖË∂äÊØÅÁÅ≠", "ÊÑøËß£ËÑ±ÊàòËÉúÊùüÁºö", "ÊÑøÁ©∫ÁÅµÂ°´Ë°•Á©∫Ëôö", "ÊÑøÁ∫ØÂáÄÈ©±ÈÄêÊ±°Êµä"]
            };

            const englishPrayPrayers = {
                openings: ["In the universe where all things have spirit", "When heaven and earth unite", "In nature's embrace", "Among silent mountains and waters", "In the river of time", "At the break of dawn", "Under the moonlit sky", "Through the turning of seasons", "In the stillness of night", "When all is quiet", "In moments of inner peace", "Where heaven and earth meet"],
                subjects: ["I pray to the stones", "I pray to the trees", "I pray to the flowing water", "I pray to the wind", "I pray to the earth", "I pray to the stars", "I pray to the mountains", "I pray to the clouds", "I pray to the rain", "I pray to the flowers", "I pray to the sun and moon", "I pray to all living things"],
                wishes: ["May my spirit find peace", "May wisdom flow like a spring", "May body and mind exist in harmony", "May I find the inner light", "May I be one with all things", "May I feel the connection of life", "May my soul be nourished", "May I find serenity within", "May I sense nature's breath", "May my heart be filled with love and compassion", "May I perceive life's beauty", "May I understand the spirit of all beings"],
                closings: ["Gratitude for the gifts of all things", "Thanks for nature's blessings", "May spiritual light illuminate the path", "Walk with nature, coexist with all beings", "With reverence, grateful for the present", "May the light of life never fade", "In harmony with heaven and earth, befriend all things", "Grateful for this moment of existence", "May gratitude always fill my heart", "All things have spirit, all deserve reverence"]
            };

            const englishReliefPrayers = {
                openings: ["As darkness begins to fade", "Where negative energy gathers", "In moments of inner chaos", "When shadows loom heavy", "As demons of the mind arise", "In times of pain's embrace", "When confusion clouds the way", "Where resentment accumulates", "In the grip of attachment", "As fear takes root", "When anxiety fills the air", "In the presence of unhealed wounds"],
                subjects: ["I summon the power of purification", "I invoke the force of deconstruction", "I channel the light of dissolution", "I release the fire of destruction", "I unleash the wind of cleansing", "I activate the thunder of shattering", "I awaken the water of transformation", "I open the blade of separation", "I ignite the flame of burning", "I deploy the force of breaking", "I turn the current of washing", "I cast the art of disintegration"],
                wishes: ["Turn negative emotions into ashes", "Let painful memories scatter in the wind", "Dissolve and decompose dark energy", "Shatter the shackles of obsession", "Melt away the heart of resentment", "Burn the source of fear to nothing", "Uproot anxiety from its foundation", "Let the fog of sorrow dissipate", "Break the chains of trauma completely", "Return confusion to nothingness", "Let binding forces crumble to dust", "Sink the weight of burdens into the abyss"],
                closings: ["May lightness replace heaviness", "May brightness dispel darkness", "May rebirth replace decay", "May freedom break through imprisonment", "May clarity cleanse chaos", "May calmness smooth turbulence", "May renewal transcend destruction", "May liberation conquer bondage", "May spaciousness fill emptiness", "May purity expel pollution"]
            };

            let prayerElements;
            if (mode === 'pray') {
                prayerElements = language === 'zh' ? chinesePrayPrayers : englishPrayPrayers;
            } else {
                prayerElements = language === 'zh' ? chineseReliefPrayers : englishReliefPrayers;
            }

            document.getElementById('backgroundVideo').style.display = 'none';
            document.querySelector('.video-overlay').style.display = 'none';
            document.querySelector('.prayer-container').style.background = '#000000';

            const opening = prayerElements.openings[Math.floor(Math.random() * prayerElements.openings.length)];
            const subject = prayerElements.subjects[Math.floor(Math.random() * prayerElements.subjects.length)];
            const wish = prayerElements.wishes[Math.floor(Math.random() * prayerElements.wishes.length)];
            const closing = prayerElements.closings[Math.floor(Math.random() * prayerElements.closings.length)];

            const separator = language === 'zh' ? 'Ôºå' : ', ';
            const period = language === 'zh' ? '„ÄÇ' : '.';
            const prayer = `${opening}${separator}${subject}${separator}${wish}${period}${closing}${period}`;

            const prayButtons = document.getElementById('prayButtons');
            prayButtons.style.opacity = '0';

            setTimeout(() => {
                prayButtons.style.display = 'none';
                const prayerTextDiv = document.getElementById('prayerText');
                prayerTextDiv.style.display = 'flex';
                prayerTextDiv.innerHTML = `<p>${prayer}</p>`;
                prayerTextDiv.style.opacity = '0';

                document.getElementById('additionalInput').style.display = 'block';

                setTimeout(() => {
                    prayerTextDiv.style.transition = 'opacity 0.8s ease-in';
                    prayerTextDiv.style.opacity = '1';

                    setTimeout(() => {
                        const elementWheel = document.getElementById('elementWheel');
                        elementWheel.style.display = 'block';
                        wheelRotating = true;
                        initElementWheelInteractions();
                        animateElementWheel();
                    }, 800);
                }, 100);
            }, 300);
        }

        function connectWithElement(element) {
            const generatedText = document.getElementById('prayerText').querySelector('p').textContent;
            const additionalInput = document.getElementById('additionalPrayer').value.trim();
            const combinedText = additionalInput ? generatedText + ' ' + additionalInput : generatedText;

            document.getElementById('prayerOverlay').classList.add('hidden');
            document.getElementById('prayAgainButton').style.display = 'block';
            setTimeout(() => {
                document.getElementById('prayAgainButton').style.opacity = '1';
            }, 100);

            let effectType;
            if (currentPrayerMode === 'pray') {
                switch(element) {
                    case 'metal': effectType = 'metal'; break;
                    case 'wood': effectType = 'wood'; break;
                    case 'water': effectType = 'water'; break;
                    case 'fire': effectType = 'fire'; break;
                    case 'earth': effectType = 'earth'; break;
                }
            } else {
                switch(element) {
                    case 'metal': effectType = 'shatter'; break;
                    case 'wood': effectType = 'wood-break'; break;
                    case 'water': effectType = 'flood'; break;
                    case 'fire': effectType = 'burn'; break;
                    case 'earth': effectType = 'earth-crack'; break;
                }
            }

            createParticles(combinedText, effectType);
            animate();
        }

        function restartPrayer() {
            const prayButtons = document.getElementById('prayButtons');
            const prayerOverlay = document.getElementById('prayerOverlay');
            const prayAgainButton = document.getElementById('prayAgainButton');

            document.getElementById('backgroundVideo').style.display = 'block';
            document.querySelector('.video-overlay').style.display = 'block';
            document.querySelector('.prayer-container').style.background = 'linear-gradient(135deg, #1a1a2e 0%, #0f3460 50%, #16213e 100%)';

            prayAgainButton.style.opacity = '0';
            setTimeout(() => {
                prayAgainButton.style.display = 'none';
                prayerOverlay.classList.remove('hidden');
                document.getElementById('prayerText').style.display = 'none';
                document.getElementById('additionalInput').style.display = 'none';
                document.getElementById('elementWheel').style.display = 'none';
                document.getElementById('additionalPrayer').value = '';

                wheelRotating = false;
                if (wheelAnimationId) cancelAnimationFrame(wheelAnimationId);

                prayButtons.style.display = 'flex';
                prayButtons.style.opacity = '0';
                setTimeout(() => {
                    prayButtons.style.transition = 'opacity 0.5s ease-in';
                    prayButtons.style.opacity = '1';
                }, 100);
            }, 300);
        }
    </script>
</body>
</html>
